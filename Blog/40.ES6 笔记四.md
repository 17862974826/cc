# ES6 笔记四 - Set Map

## Set

### 基本用法
类似数组，但是成员都是唯一的没有重复值。

Set本身是一个构造函数用来生成Set类型的数据

Set可以接受一个数组或者类数组的对象作为参数来初始化

```js
var s = new Set([1,2,3,3,3,4,5])
s.size  // 5
[...s]  // [1,2,3,4,5]

var ss = new Set([...document.querySelectorAll('div')]);
ss.size // div的个数

// 相当于
[...document.querySelectorAll('div')].forEach(div => ss.add(div))
```

使用 Set 数组去重 ` [...new Set(array)] `

使用 Set 加入值时不会转换类型 5 和 '5' 是两个不同的值。虽然 `NaN === NaN` 返回 false, 但是在 Set 内部 NaN 是等于自身的。

```js
var set = new Set();
var a = NaN;
var b = NaN;

set.add(a);
set.add(b);

set.size // 1  Set 内部 两个 NaN 是相等的
```

但是两个对象总是不等的

```js
var set = new Set();

set.add({});
set.add({});

set.size // 2
```

### 属性 方法

#### 1. 属性

* `Set.prototype.constroctor` 构造函数
* `Set.prototype.size` Set 实例的成员总数

#### 2.1 操作方法

* add(value) 返回 Set 本身
* delete(value) 返回 Booolean
* has(value) 返回 Booolean
* clear()

`Array.from` 可以将 Set 结构转为数组

```js
var s = new Set([1,2,3,4]);

var arr = Array.from(s);

arr // [1, 2, 3, 4]
```

数组去重的另一种方法

```js
var unique = function(arr){
    return Array.from(new Set(arr))
}

unique([1,2,2,3,3,4]);
```
#### 2.2 遍历方法

* keys() 返回键名
* values()  返回键值
* entries()  返回键值对
* forEach() 用回调遍历所有成员

Set 遍历的顺序就是插入顺序。如果使用Set保存一个回调函数的列表，调用时就能按照添加的顺序来调用。

##### 1) keys()，values()，entries()

key()、values()、entries()返回的都是遍历器对象。因为 Set 没有键名(或者键名和键值是同一个值)，所以key()和value()的行为完全一致。

```js
var set = new Set(['aa', 'bb', 'cc']);

for (var item of set.keys()) {
  console.log(item);
}
// aa
// bb
// cc

for (var item of set.values()) {
  console.log(item);
}
// aa
// bb
// cc

for (var item of set.entries()) {
  console.log(item);
}
// ["aa", "aa"]
// ["bb", "bb"]
// ["cc", "cc"]
```

Set 结构的实例默认可以遍历 它的默认遍历器生成函数就是它的 `values` 方法

` Set.prototype[Symbol.iterator] === Set.prototype.values `

那么就可以直接用 ` for...of ` 来遍历Set。省略 values 方法。

```js
var set = new Set(['aa', 'bb', 'cc']);

for(s of set) {
    console.log(s);
}
// aa
// bb
// cc
```

##### 2) forEach()

```js
var set = new Set(['aa', 'bb', 'cc']);

set.forEach((val,key) => console.log(val + ' - sss'))

```

##### 3) 使用遍历

扩展运算符 (...) 内部使用 `for...of` 循环，所以也可以是用 Set 结构。

```js
var set = new Set(['a', 'b', 'c']);

var arr = [...set];

// ['a', 'b', 'c']
```

数组的 `map` `filter` 方法也可用于 Set

```js
var set = new Set([1, 2, 3]);
set = new Set([...set].map(x => x*2));
// Set {2, 4, 6}

var set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter(x => (x%2) ==0 ));
// Set {2, 4}
```

Set 很容易实现并集（Union）、交集（Intersect）和差集（Difference）

```js
var a = new Set([1,2,3]);
var b = new Set([2,3,4]);

var union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}

var intersect = new Set([...a].filter(x => b.has(x) ));
// Set {2, 3}

var diff = new Set([...a].filter(x => !b.has(x) ));
// Set {1}
```

## WeakSet

与 Set 区别

* WeakSet 的成员只能是对象
* WeakSet 中的对象都是弱引用。  
  如果其他对象不再引用该对象，那 GC 会自动回收该对象占用的内存，不考虑该对象还存在于 WeakSet 中。  
  那就无法引用 WeakSet 的成员，因此 WeakSet 不可遍历。

```js
var ws = new WeakSet();
ws.add(1); // Uncaught TypeError: Invalid value used in weak set
ws.add(Symbol()); // Uncaught TypeError: Invalid value used in weak set

```

```js
var a = [[1,2], [3,4]];
var ws = new WeakSet(a);
```

上面代码中 a 数组的成员成为 WeakSet 的成员，而不是 a 数组本身。因此数组的成员只能是对象。


WeakSet 没有 `size` `forEach` 属性，没有办法遍历它的成员。

WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。


## Map









