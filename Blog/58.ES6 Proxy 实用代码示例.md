# 用实例代码理解 ES6 Proxy

建议先阅读 MDN 上关于 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 和 [Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect) 的文档

## 基础

Proxy 是通过包装对象，用拦截的方式来修改某些操作的默认行为，比如获取属性值。我们可以为需要拦截的对象提供一个带有 [traps](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Terminology) 的函数对象，如果对象操作没有定义 trap 将会指向原始的对象操作上。

```js
const hanlder = {
  get(target, prop) {
    const val = target[prop]
    console.log(`property ${prop} = ${val}`)
    return val
  }
}

const p = new Proxy({a: 1}, hanlder)

console.log(p.a)
// property a = 1
// 1
console.log(p.b)
// property b = undefined
// 1
```
上面代码中当要获取 `p.a` 值时，`hanlder.get` 这个 trap 就会被调用，相当于我们劫持了 `p.a` 中的 . 操作符，于是就不能再去访问原始对象，我们在劫持中就可以做例如验证、封装、访问控制等各种操作了。


## 默认值

当我们请求一个对象中不存在的 key 时，我们可以从对象中提供一个默认值，不过要注意， `in` 操作符仍然能知道这个 key 是否在对象中存在。

```js
function defaultProp(defaultObj){
  const handler = {
    get(obj, prop) {
      return Reflect.get(obj, prop) || defaultObj[prop];
    }
  };
  return new Proxy({}, handler);
}

function test(){
  const exist = 'name' in o ? 'in' : 'not in'
  console.log(`name = "${o.name}", name ${exist} o`)
}

const o = defaultProp({ name: 'default name'})


test() // name = "default name", name not in o

o.name = 'abcdef'
test() // name = "abcdef", name in o

delete o.name
test() // name = "default name", name not in o

```


## 隐藏私有属性

Proxy 也有利于限制属性的访问，比如隐藏以下划线开头的的属性，让他们真正私有化。

上面两个例子相对简单，这个的代码就麻烦点了，先上代码，后面解释： 

```js
function priavateProp(obj, filter){
  const hanlder = {
    get(obj, prop) {
      if(!filter(prop)){
        let val = Reflect.get(obj, prop)
        if(typeof val === 'function'){
          val = val.bind(obj)
        }
        return val
      }
    },
    set(obj, prop, val) {
      if(filter(prop)){
        throw new Error(`cannot set property ${prop}`)
      }
      return Reflect.set(obj, prop, val)
    },
    has(obj, prop) {
      return filter(prop) ? false : Reflect.has(obj, prop)
    },
    ownKeys(obj) {
      return Reflect.ownKeys(obj).filter( prop => !filter(prop))
    }
  }

  return new Proxy(obj, hanlder)
}
// 私有属性过滤器
function filter(prop){
  return prop.indexOf('_') === 0
}

const o = {
  _private: 'private property',
  name: 'public name',
  say(){
    // 内部访问私有属性
    console.log(this._private)
  }
}

const p = priavateProp(o, filter)

console.log(p)  // Proxy {_private: "private property", name: "public name"}

p._private  // undefined
JSON.stringify(p) // "{"name":"public name"}"
// 只能内部访问私有属性
p.say()  //  private property

console.log('_private' in p)   // false

// 不能遍历到私有属性 
Object.keys(p)  // ["name", "say"]

p._private = '000'  // Uncaught Error: cannot set property _private

```

上面代码使用了4个 trap 函数来实现，参数 `filter` 函数是用来过滤私有属性的过滤器。`has` 函数因为在 Proxy 中用来监听对象 `in` 的使用，所以成了过滤私有属性的核心。`ownKeys` 过滤私有属性，让 `Object.keys(p)` 返回其他所有属性。

注意，因为在 Proxy 上调用方法, `this` 默认指向的是 Proxy ，而不是原始对象，因此方法将无法访问私有属性，所以通过将方法绑定到 `get` 函数中来解决。


## 枚举 Enum

js 中可用对象操作或者 `Object.freeze` 的方式来实现枚举，但有时候会出现类型安全的问题，因此很不健壮。

通过 Proxy ，我们创建一个键值对象，通过阻止修改其值来保证其健壮性，同时比 `Object.freeze` 更安全。（虽然 `Object.freeze` 可以阻止内容被修改，但不会抛出错误，所以会隐藏潜在的 bug）

我们先实现一个 Enum ，然后在和其他枚举的方式做下对比

```js
function Enum(){
  
}
```












