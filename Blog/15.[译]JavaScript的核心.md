# JavaScript的核心

http://weizhifeng.net/javascript-the-core.html

[原文](http://dmitrysoshnikov.com/ecmascript/javascript-the-core/)

> 1. 对象
> 2. 原型链
> 3. 构造函数
> 4. 执行上下文栈
> 5. 执行上下文
> 6. 变量对象
> 7. 活动对象
> 8. 作用域链
> 9. 闭包
> 10. this
> 11. 结论

这篇文章是“深入理解ECMA-262-3”的一个总览和概要，每个章节都有对应的详细的链接。

## 对象
ECMAScript作为一个高度抽象的面向对象语言，是通过**对象**来做数据传递的。当然也有一些基本数据类型，但通常也会被转换为对象来处理。

> 一个对象就是一组属性的集合，并拥有一个独立的prototype对象，这个prototype可以是个对象也可以是个null

举个简单例子，对象的 prototype 是以内部的`[[Prototype]]`属性来引用的。但是我们在图表中使用 `__<internal-property>__`下划线标记来代替双括号，尤其是prototype对象：`__proto__`

代码如下：

```
var foo = {
  x: 10,
  y: 20
};
```
于是就有这个结构：两个显式的自身属性和一个隐式属性`__proto__`,这个隐式属性就是对 foo 原型对象的引用  

![](http://gtms01.alicdn.com/tps/i1/TB1TKBkHFXXXXXrXVXXWgfqSXXX-377-118.png)

为什么需要这些prototype？那我们就以原型链 (prototype chain) 的概念来回答这个问题。

## 原型链

原型对象也是简单对象，并且也有自己的原型。如果一个原型对象的原型有一个非空(not null)的引用，那么以此类推，这就叫做原型链。
> 原型链是一个可以实现继承和对象共享的有限对象链

假设我们有两个对象，其中只有一小部分不同，其他绝大部分相同。很明显，对于一个有良好设计的系统，我们会复用相似的函数和代码。在基于类的系统中，代码复用风格叫做类继承`class-based inheritance` —— 把一组相似的功能放入Class A，然后Class B和C继承Class A，并又有独自的小改动。

ECMAScript中没有类的概念。但是代码复用的风格并没有多大的不同（尽管从某些方面来说这种方式比累积成要更灵活）并且通过原型链来实现。这种集成被称作委托继承`(delegation based inheritance)`(或者用ECMAScript的范式来说就叫做原型继承)。

类似子上面例子中的类A、B、C，在ECMAScript中创建对象a、b、c。那么在a中存储b、c通用的部分，b、c只存储自己额外属性和方法。  
代码如下：

```
var a = {
  x: 10,
  calculate: function (z) {
    return this.x + this.y + z;
  }
};
 
var b = {
  y: 20,
  __proto__: a
};
 
var c = {
  y: 30,
  __proto__: a
};
 
// call the inherited method
b.calculate(30); // 60
c.calculate(40); // 80
```

足够简单，对吧。b和c调用了a中的calculate方法，这就叫做原型链继承。

规则很简单：一个属性或一个方法没有在对象自身中找到（即对象自身没有那个属性），然后就尝试在原型中查找这个属性或者方法，如果原型中没有找到，就会继续查找原型的原型，以此来遍历整个原型链（当然这在基于类继承中是一样的，调用继承方法时会遍历真个Class链）

