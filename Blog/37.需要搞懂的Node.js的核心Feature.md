# Node.js的核心Feature

>
1. Event Loop 事件循环
2. global 和 process
3. Event emitters 事件执行
4. stream 和 buffer
5. cluster
6. 异步error
7. C++ 插件
>


## Event Loop

事件循环算是Node的一个核心了，即使进程中有I/O调用也能处理其他任务。正因为阻塞I/O代价太高所以就凸显了Node的高效。

![](http://ww3.sinaimg.cn/large/72f96cbagw1f71r7wtpukj20lb0ce75j.jpg)

在 Python 这样来实现一个延迟处理

```python
import time

print "Step 1"
print "Step 2"
time.sleep(2)
print "Step 3"
```

Node或JS 通过异步回调的方式来实现

```js
console.log('Step 1')
setTimeout(function () {
  console.log('Step 3')
}, 2000)
console.log('Step 2')
```

可以事件循环想象成一个for或while循环，只有在现在或将来没有任务要执行的时候才会停下来。

![Blocking IO](http://ww1.sinaimg.cn/large/72f96cbagw1f71rn4dyttj20es08paal.jpg)

在等待I/O任务完成之前就可以做更多事情，事件循环因此让系统更加高效。

![Non-Blocking IO](http://ww2.sinaimg.cn/large/72f96cbagw1f71rrvp41vj20gf08faap.jpg)

Node也让我们从死锁中解放，因为根本没有锁。

PS：我们仍然可以写出阻塞的代码

```js
var start = Date.now()
for (var i = 1; i<1000000000; i++) {}
var end = Date.now()
console.log(end-start)
```
这次的阻塞在我的机器上花了3400多毫秒。不过我们多数情况下不会跑一个空循环。

而且fs模块提供了同步(阻塞)和异步(非阻塞)两套处理方法(区别于方法名后是否有Sync)

如下阻塞方式的代码:

```js
var fs = require('fs');
	
var con1 = fs.readFileSync('1.txt','utf8');
console.log(con1);
console.log('read 1.txt');
	
var con2 = fs.readFileSync('2.txt','utf8');
console.log(con2);
console.log('read 2.txt');
```
结果就是

`content1->read 1.txt->content2->read 2.txt`

非阻塞方式的代码:

```js
var fs = require('fs');

fs.readFile('1.txt','utf8', function(err, contents){
   console.log(contents);
});
console.log('read 1.txt');

fs.readFile('2.txt','utf8', function(err, contents){
   console.log(contents);
});
console.log("read 2.txt");
```

代码执行后因为要花时间执行**读**的操作，所以会在最后的回调函数中打印出文件内容。当读取操作结束后事件循环就会拿到内容

`read 1.txt->read 2.txt->content1->content2 `

事件循环的概念对前端工程师比较好理解，关键就是异步、非阻塞I\O。

## global

从浏览器端切换到Node端就会出现几个问题

  * 全局变量如何创建(window对象已经没了)
  * 从 CLI 输入的参数、系统信息、内存信息、版本信息等从哪获取

有一个 global 对象，顾名思义就是全局的，它的属性很多

  * global.process 可获取版本信息、CLI 参数、内存使用(process.memoryUsage()这个函数很好用)
  * global.__filename 当前脚本的文件名、路径
  * global.__dirname 当前脚本绝对路径
  * global.module 最常见的模块输出
  * global.require() 模块引入
  * global.console()、setInterval()、setTimeout() 这些浏览器端的方法也在global对象下面

在命令行里执行一次 global 一切就都懂了。

## process

  



